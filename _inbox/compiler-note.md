---
title: 编译原理学习笔记
date: 2024-01-26 20:29:40
author: xeonds
toc: true
excerpt: 你说的对，但是编译器是一款......
tags:
---

这东西很早就开始看，但是一直没有一个明晰的思路。说起来最早接触编译器，大概是第一次试着自己写一个计算器的时候吧。那会尝试使用递归来进行表达式的解析，现在想来很像下推自动机。

## 编译器纲要

编译原理的根本目的是将程序设计高级语言翻译成机器硬件控制器可直接执行的二进制代码。自顶向下观测，可以从编译的阶段流程逐步深入学习。

首先是概览，理解每个阶段的输入和输出，从黑箱角度理解每一阶段的编译器组件的功能，参考龙书。

其次从词法分析开始，介绍词法匹配的方法，进一步深入到本质：正则表达式（三型文法），以及有限自动机DFA。

接下来是语法分析，介绍CFG和CSG，以及配套的自动机模型：下推自动机。

## 词法分析，状态机与正则表达式

词法分析是读取输入字符流，并将它转换为

- 字母表 元素构成的集合
- 符号 构成字母表的元素。例如a,b,c是符号
- 符号串 符号的有穷序列。例如symbol。空符号串记作$\epsilon$
- 符号串长度 包含符号的个数。例如x=string，则有|x|=6
- 符号串连接 xy表示这两个符号串连接
- 符号串集合的乘积 AB={xy|x∈A,y∈B}
- 符号串的幂运算 同一个符号串的自我连接
- 符号串集合的幂运算 符号串集合的自我乘积
- 符号串集合的正闭包 是集合1到n次幂的并集
- 自反闭包 正闭包和空串集合的并集

通过离散数学的语言描述正则语言。

## 文法及其分类
### 简介

- 编译流程：词法分析，语法分析，语义分析，中间代码生成，中间代码优化，目标代码生成六步。
- 编译程序结构：包含上面6个步骤的对应程序，以及表格处理程序，出错处理程序。

按照前后端划分，前面5个步骤属于前端，最后一个步骤属于后端，因为它依赖于特定计算机硬件系统和机器指令。

同时，编译过程也可以分为一遍和多遍。

高级语言的自编译性（自举）：允许这个语言为它自己编写编译器。自展技术可以实现这一点：它把语言分为一个核心部分和数个扩充部分。用机器语言实现核心，再用核心实现扩展功能。

- 编译器移植：改后端为目标机器后端生成器，然后编译生成A上运行的B编译器，再用它编译自己，就得到了B上可用的编译器。

翻译程序编写系统，是编译器/翻译器的开发工具。它也曾被称为自动程序设计系统，这一概念包含规格说明，目标语言，问题范围和采用方法等。采用方法包括**知识工程**等。

### 文法分类

根据Chomsky文法分类，可以得到0,1,2,3型文法。数字越大越宽松：

- 0：每个产生式的左部和右部都包含于N和T全并集的闭包中，且至少有一个非终结符
- 1（上下文有关语言CSG）：除了空产生式，均有左侧小于等于右侧
- 2（上下文无关语言CFG）：产生式左部只能是非终结符
- 3（正规语言RG）：产生式右部的非终结符统一出现在最左端/最右端

越强的语法（编号越小）的自动机越难构造。程序设计语言大多是CSG，但是我们一般用CFG描述程序设计语言，将上下文有关的部分单独分离为语义分析的部分。

## 语法分析

语法分析相比词法分析使用的有穷自动机NDFA/DFA，它使用下推自动机。这种自动机模型更强一些，有部分计数功能。

### 下推自动机

> 自动机原型是图灵机。其核心模型是状态转换和状态修改。

在有限状态控制器上添加了一个信息/状态保存栈。因此，它有简单的计数能力。

### 语法分析方法

#### 自上而下语法分析

从语法树的根到叶去建立语法树。步骤是试探+回溯，边推导边匹配。对输入序列，使用产生式进行最左推导，直到得到一个合法句子/非法结构。随后从左到右扫描输入序列，自上而下建立语法树。

最大的问题是左递归，即非终结符同时出现在左部和右部左侧，会造成死循环。消除方法为引入新的非终结符进行同义转化。**直接消除左递归**的方法可以使用通用的算法进行解决。

另一个问题是消除文法二义性。直接的消除方法不适用于自上而下分析方法。

还有一个问题是公共前缀的提取。该行为能有效优化选择速度，提升性能和错误恢复能力。方法是引入新的非终结符来表示公共前缀的推导，再改写原来的产生式。
